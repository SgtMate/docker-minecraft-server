#!/bin/bash

set -e -o pipefail

: "${REMOVE_OLD_MODS:=false}"
: "${MODS:=}"
: "${MODS_OUT_DIR:=/data/mods}"
: "${MODS_FILE:=}"
: "${PLUGINS:=}"
: "${PLUGINS_OUT_DIR:=/data/plugins}"
: "${PLUGINS_FILE:=}"
: "${REMOVE_OLD_MODS_DEPTH:=1} "
: "${REMOVE_OLD_MODS_INCLUDE:=*.jar,*-version.json}"
: "${CF_API_KEY_FILE:=}" # Path to file containing CurseForge API key
: "${MODRINTH_LOADER:=}"
sum_file=/data/.generic_pack.sum

if [[ -n ${CF_API_KEY_FILE} ]]; then
  if [[ -r "${CF_API_KEY_FILE}" ]]; then
    CF_API_KEY="$(cat "${CF_API_KEY_FILE}")"
    export CF_API_KEY
  else
    logError "CF_API_KEY_FILE is not readable: ${CF_API_KEY_FILE}"
    exit 1
  fi
fi

# shellcheck source=start-utils
. "$(dirname "$0")/start-utils"
isDebugging && set -x

#  CURSE_URL_BASE used in manifest downloads below
CURSE_URL_BASE=${CURSE_URL_BASE:-https://minecraft.curseforge.com/projects}

# Remove old mods/plugins
if isTrue "${REMOVE_OLD_MODS}" && [ -z "${MODS_FILE}" ]; then
  removeOldMods "$MODS_OUT_DIR"
  removeOldMods "$PLUGINS_OUT_DIR"
  rm -f "$sum_file"
fi

function handlePackwiz() {
  # If packwiz url passed, bootstrap packwiz and update mods before other modpack processing
  if [[ "${PACKWIZ_URL:-}" ]]; then
    if ! packwizInstaller=$(mc-image-helper maven-download \
                           --maven-repo=https://maven.packwiz.infra.link/repository/release/ \
                           --group=link.infra.packwiz --artifact=packwiz-installer --classifier=dist \
                           --skip-existing); then
      logError "Failed to get packwiz installer"
      exit 1
    fi

    log "Running packwiz installer against URL: ${PACKWIZ_URL}"
    if ! java -cp "${packwizInstaller}" link.infra.packwiz.installer.Main -s server "${PACKWIZ_URL}"; then
      logError "Failed to run packwiz installer"
      exit 1
    fi
  fi
}

function handleModpackZip() {
# If supplied with a URL for a modpack (simple zip of jars), download it and unpack
if [[ "$MODPACK" ]]; then
  if isURL "${MODPACK}"; then
    log "Downloading mod/plugin pack"
    if ! get -o /tmp/modpack.zip "${MODPACK}"; then
      logError "Failed to download from ${MODPACK}"
      exit 2
    fi
  elif [[ "$MODPACK" =~ .*\.zip ]]; then
    if ! cp "$MODPACK" /tmp/modpack.zip; then
      logError "Failed to copy from $MODPACK"
      exit 2
    fi
  else
    logError "Invalid URL or Path given for MODPACK: $MODPACK"
    exit 1
  fi

  if [ "$FAMILY" = "SPIGOT" ]; then
    mkdir -p "$PLUGINS_OUT_DIR"
    if ! unzip -o -d "$PLUGINS_OUT_DIR" /tmp/modpack.zip; then
      logError "Failed to unzip the modpack from ${MODPACK}"
    fi
  else
    mkdir -p "$MODS_OUT_DIR"
    if ! unzip -o -d "$MODS_OUT_DIR" /tmp/modpack.zip; then
      logError "Failed to unzip the modpack from ${MODPACK}"
    fi
  fi
  rm -f /tmp/modpack.zip
fi
}

function handleListings() {
  if usesMods && usesPlugins; then
      if [[ "$MODS" ]]; then

        ensureRemoveAllModsOff "MODS is set"

        mkdir -p "$MODS_OUT_DIR"
        mc-image-helper mcopy \
          --glob=*.jar \
          --scope=var-list \
          --to="$MODS_OUT_DIR" \
          "$MODS"
      fi
      if [[ "$PLUGINS" ]]; then
        ensureRemoveAllModsOff "PLUGINS is set"
        mkdir -p "$PLUGINS_OUT_DIR"
        mc-image-helper mcopy \
          --glob=*.jar \
          --scope=var-list \
          --to="$PLUGINS_OUT_DIR" \
          "$PLUGINS"
      fi

      if [[ "$MODS_FILE" ]]; then
        ensureRemoveAllModsOff "MODS_FILE is set"
        mkdir -p "$MODS_OUT_DIR"
        mc-image-helper mcopy \
          --file-is-listing \
          --scope=file-list \
          --to="$MODS_OUT_DIR" \
          "$MODS_FILE"
      fi
      if [[ "$PLUGINS_FILE" ]]; then
        ensureRemoveAllModsOff "PLUGINS_FILE is set"
        mkdir -p "$PLUGINS_OUT_DIR"
        mc-image-helper mcopy \
          --file-is-listing \
          --scope=file-list \
          --to="$PLUGINS_OUT_DIR" \
          "$PLUGINS_FILE"
      fi

  elif usesPlugins || usesMods; then
    outDir="$MODS_OUT_DIR"
    if usesPlugins; then
      outDir="$PLUGINS_OUT_DIR"
    fi

    if [[ "$MODS" || "$PLUGINS" ]]; then
      ensureRemoveAllModsOff "MODS or PLUGINS is set"
      mkdir -p "$outDir"
      mc-image-helper mcopy \
        --glob=*.jar \
        --scope=var-list \
        --to="$outDir" \
        "$MODS" "$PLUGINS"
    fi

    if [[ "$MODS_FILE" || "$PLUGINS_FILE" ]]; then
      ensureRemoveAllModsOff "MODS_FILE or PLUGINS_FILE is set"
      mkdir -p "$outDir"
      mc-image-helper mcopy \
        --file-is-listing \
        --scope=file-list \
        --to="$outDir" \
        "$MODS_FILE" "$PLUGINS_FILE"
    fi

  fi
}

function handleGenericPacks() {
  : "${GENERIC_PACKS:=${GENERIC_PACK}}"
  : "${GENERIC_PACKS_PREFIX:=}"
  : "${GENERIC_PACKS_SUFFIX:=}"
  : "${GENERIC_PACKS_DISABLE_MODS:=}"

  if [[ "${GENERIC_PACKS}" ]]; then
    IFS=',' read -ra packs <<< "${GENERIC_PACKS}"

    packFiles=()
    for packEntry in "${packs[@]}"; do
      pack="${GENERIC_PACKS_PREFIX}${packEntry}${GENERIC_PACKS_SUFFIX}"
      if isURL "${pack}"; then
        mkdir -p /data/packs
        log "Downloading generic pack from $pack"
        if ! outfile=$(get -o /data/packs --output-filename --skip-up-to-date "$pack"); then
          logError "Failed to download $pack"
          exit 2
        fi
        packFiles+=("$outfile")
      else
        packFiles+=("$pack")
      fi
    done

    isDebugging && [ -f "$sum_file}" ] && cat "$sum_file"

    log "Checking if generic packs are up to date"
    if isTrue "${SKIP_GENERIC_PACK_UPDATE_CHECK:-false}" && [ -f "$sum_file" ]; then
      log "Skipping generic pack update check"
    elif isTrue "${FORCE_GENERIC_PACK_UPDATE}" || ! checkSum "${sum_file}"; then
      log "Generic pack(s) are out of date. Re-applying..."

      original_base_dir=/data/.tmp/generic_pack_base
      base_dir=$original_base_dir
      rm -rf "${base_dir}"
      mkdir -p "${base_dir}"
      for pack in "${packFiles[@]}"; do
        isDebugging && ls -l "${pack}"
        extract "${pack}" "${base_dir}"
      done

      # Disable mods
      for mod in ${GENERIC_PACKS_DISABLE_MODS}; do
        log Disabling $mod
        find "${base_dir}" -name "$mod" -exec mv {} {}.disabled -v \;
      done

      # Remove any eula file since container manages it
      rm -f "${base_dir}/eula.txt"

      # recalculate the actual base directory of content
      if ! base_dir=$(mc-image-helper find \
          --max-depth=3 --type=directory --name=mods,plugins,config \
          --only-shallowest --fail-no-matches --format '%h' \
          "$base_dir"); then
        logError "Unable to find content base of generic packs ${GENERIC_PACKS}. Directories:"
        mc-image-helper find --name=* --max-depth=3 --type=directory --format '- %P' "$original_base_dir"
        exit 1
      fi

      if [ -f /data/manifest.txt ]; then
        log "Manifest exists from older generic pack, cleaning up ..."
        while read -r f; do
          rm -rf "/data/${f}"
        done < /data/manifest.txt
        # prune empty dirs
        find /data -mindepth 1 -depth -type d -empty -delete
        rm -f /data/manifest.txt
      fi

      log "Writing generic pack manifest ... "
      find "${base_dir}" -type f -printf "%P\n" > /data/manifest.txt

      log "Applying generic pack ..."
      cp -R -f "${base_dir}"/* /data
      rm -rf $original_base_dir

      if isTrue "${SKIP_GENERIC_PACK_CHECKSUM:-false}"; then
        log "Skipping generic pack(s) checksum"
      else
        log "Saving generic pack(s) checksum"
        sha1sum "${packFiles[@]}" > "${sum_file}"
        if isDebugging; then
          cat "$sum_file"
        fi
      fi
    fi
  fi
}

function handleGTNH() {
  # Possible Options: VERSION_NUMBER, latest, latest-dev
  : "${GTNH_PACK_VERSION:=latest}"
  : "${GTNH_DELETE_BACKUPS:=false}"
  : "${SKIP_GTNH_UPDATE_CHECK:=false}"
  log "GTNH VAR CHECK $GTNH_DELETE_BACKUPS, $GTNH_PACK_VERSION, $TYPE, $SKIP_GTNH_UPDATE_CHECK"

  if isTrue "$GTNH_DELETE_BACKUPS"; then
    log "Start deleting all config backups"
    if deleted_backups="$(mc-image-helper find --name="gtnh-upgrade-*" --delete --max-depth=1 --type directory /data)" ; then
    log "Deleting: $deleted_backups"
    else
    log "No GTNH backups found."
    fi
  fi

  if [[ -n $GTNH_PACK_VERSION ]] && isFalse "$SKIP_GTNH_UPDATE_CHECK" ; then
    gtnh_download_path=""
    current_java_version=$(mc-image-helper java-release)
    
    if ! mapfile -t packs < <(curl -sfL 'http://downloads.gtnewhorizons.com/ServerPacks/?raw'); then
      logError "Failed to retrieve data from http://downloads.gtnewhorizons.com/ServerPacks/?raw"
      exit 1
    fi

    log "Start locating server files..."
    for pack in "${packs[@]}"; do
      # Extract the Java version(s) from the pack filename
      if ! pack_java_version=$(basename "$pack" | grep -Eo 'Java_[0-9]+(-[0-9]+)?' | sed 's/Java_//'); then
      logWarning "Could not parse java version of $pack"
      fi

      # Skip the pack if the current Java version is not compatible
      if [[ "$pack_java_version" == *-* ]]; then
        # Handle range of Java versions (e.g., "17-21")
        java_min_version=$(echo "$pack_java_version" | cut -d'-' -f1)
        java_max_version=$(echo "$pack_java_version" | cut -d'-' -f2)
        if (( current_java_version < java_min_version || current_java_version > java_max_version )); then
          log "Skipping $pack due to incompatible Java version: $current_java_version not in range $java_min_version-$java_max_version"
          continue
        fi
      else
        # Handle single Java version (e.g., "8")
        if (( current_java_version != pack_java_version )); then
          log "Skipping $pack due to incompatible Java version: $current_java_version != $pack_java_version"
          continue
        fi
      fi

      # Extract version numbers and release type (beta or RC) from the file names
      
      if ! pack_version=$(basename "$pack" | grep -Eo '[0-9]+(\.[0-9]+)+'); then
      logWarning "Could not parse version of $pack"
      fi
      if ! pack_release_type=$(basename "$pack" | grep -Eo '(beta|RC)(-[0-9]+)?' || echo ""); then
      logWarning "Could not parse release type of $pack"
      fi
      if ! current_version=$(basename "$gtnh_download_path" | grep -Eo '[0-9]+(\.[0-9]+)+'); then
      log "Could not parse version of selected download path. String might be empty."
      fi
      if ! current_release_type=$(basename "$gtnh_download_path" | grep -Eo '(beta|RC)(-[0-9]+)?' || echo ""); then
      log "Could not parse release type of selected download path. String might be empty."
      fi
      # Check if the pack matches the desired type based on GTNH_PACK_VERSION:
      # - If GTNH_PACK_VERSION is "latest-dev", only consider beta packs (path contains "/betas/").
      # - If GTNH_PACK_VERSION is "latest", only consider non-beta packs (path does not contain "/betas/").
      if [[ ($pack == "*/betas/*" && $GTNH_PACK_VERSION == "latest-dev") || ($pack != "*/betas/*" && $GTNH_PACK_VERSION == "latest") ]]; then
        # Compare versions and update gtnh_download_path if pack is newer
        # Check if the current version is unset or if the pack version is newer than the current version.
        # This comparison uses version sorting to determine the latest version.
        if [[ -z "$current_version" || "$(printf '%s\n' "$pack_version" "$current_version" | sort -V | tail -n 1)" == "$pack_version" ]]; then
          
          # If the pack version is the same as the current version, prioritize based on release type.
          # Full versions are preferred over RC (Release Candidate), and RC is preferred over beta.
          # Within the same release type, higher numbered versions are preferred.
          if [[ "$pack_version" == "$current_version" ]]; then
          if [[ -z "$pack_release_type" || ("$pack_release_type" == "RC" && "$current_release_type" == "beta") || 
              ("$pack_release_type" == "$current_release_type" && "$(printf '%s\n' "$pack_release_type" "$current_release_type" | sort -V | tail -n 1)" == "$pack_release_type") ]]; then
            log "$current_version-$current_release_type is older than $pack_version-$pack_release_type! Update latest version to: $pack_version-$pack_release_type"
            gtnh_download_path="$pack"
          fi
          else
          # If the pack version is newer than the current version, set it as the download path.
          log "$current_version is older than $pack_version! Update latest version to: $pack_version"
          gtnh_download_path="$pack"
          fi
        fi
      else
        if [[ "$pack_version" == "$GTNH_PACK_VERSION" || "$pack_version-$pack_release_type" == "$GTNH_PACK_VERSION" ]]; then
          log "Found exact match $pack_version = $GTNH_PACK_VERSION! Select $pack_version for download."
          gtnh_download_path="$pack"
          break
        fi
      fi
    done
    
    if [[ -z $gtnh_download_path ]]; then
    logError "Server files not found for GTNH_PACK_VERSION=$GTNH_PACK_VERSION! Download not possible!"
    exit 1
    fi
    log "Server files located! Will proceed update $gtnh_download_path."

    # Decide if update or install is needed or not.
    if [[ ! -f /data/.gtnh-version || "$(basename "$gtnh_download_path")" != "$(cat /data/.gtnh-version)" ]]; then
      log "Update/Install required: /data/.gtnh-version is missing or does not match the selected version $(basename "$gtnh_download_path")."

      mkdir -p /data/packs
      log "Downloading $gtnh_download_path."
      if ! gtnh_download=$(mc-image-helper get -o /data/packs --output-filename --skip-up-to-date "$gtnh_download_path"); then
        logError "Failed to download $gtnh_download_path"
        exit 1
      fi
      
      # Unpacking Server files into temporary directory
      log "Unpacking Server Files..."
      original_base_dir=/data/.tmp/gtnh_base
      base_dir=$original_base_dir
      rm -rf "${base_dir}"
      mkdir -p "${base_dir}"
      extract "${gtnh_download}" "${base_dir}"
      trap 'rm -rf /data/.tmp/gtnh_base' EXIT
      # Removing downloaded zip
      rm -f "$gtnh_download"

      # Remove any eula file since container manages it
      rm -f "${base_dir}/eula.txt"

      # recalculate the actual base directory of content
      if ! base_dir=$(mc-image-helper find \
          --max-depth=3 --type=directory --name=mods,config \
          --only-shallowest --fail-no-matches --format '%h' \
          "$base_dir"); then
        logError "Unable to find content base of downloaded Server Files"
        exit 1
      fi

      # Split installation from update path. Check for version file.
      if [[ -f /data/.gtnh-version ]]; then
        log ".gtnh-version file detected! Assuming old version already exists. Proceed updating existing server..."
        # Get the current date and time
        current_datetime=$(date +%Y-%m-%dT%H:%M)

        # Define folders and files to update
        folders_to_update=("libraries" "mods" "resources" "scripts")
        files_to_update=("lwjgl3ify-forgePatches.jar" "java9args.txt" "startserver-java9.bat" "startserver-java9.sh" "forge-1.7.10-10.13.4.1614-1.7.10-universal.jar" "startserver.bat" "startserver.sh" "server-icon.png")
        config_folder="config"
        backup_folder="/data/gtnh-upgrade-${pack_version}${pack_release_type:+-$pack_release_type}-$current_datetime"
        journey_map_folder="JourneyMapServer"

        # Delete specified folders if they exist
        for folder in "${folders_to_update[@]}"; do
            folder_path="/data/$folder"
            if [[ -d "$folder_path" ]]; then
                log "Deleting folder: $folder_path"
                rm -rf "$folder_path"
            fi
        done

        # Delete specific files if they exist
        for file in "${files_to_update[@]}"; do
            file_path="/data/$file"
            if [[ -f "$file_path" ]]; then
                log "Deleting file: $file_path"
                rm -f "$file_path"
            fi
        done

        # Backup the config folder
        if [[ -d "/data/$config_folder" ]]; then
            log "Creating backup of /data/$config_folder at $backup_folder"
            cp -r "/data/$config_folder" "$backup_folder"
            log "Deleting original /data/$config_folder"
            rm -rf "/data/$config_folder"
        fi

        # Updating the required folders in data directory
        for folder in "${folders_to_update[@]}" "$config_folder"; do
          if [[ -d "$base_dir/$folder" ]]; then
            log "Copying $folder to /data"
            cp -r "$base_dir/$folder" "/data/"
          else
            logWarning "Folder $folder not found in the unzipped data!"
          fi
        done
        
        # Copy specific files to the /data directory
        for file in "${files_to_update[@]}"; do
          if [[ -f "$base_dir/$file" ]]; then
            log "Copying $file to /data"
            cp "$base_dir/$file" "/data/"
          else
            logWarning "File $file not found in the unzipped data!"
          fi
        done

        # Ensure the config folder exists
        if [[ ! -d "$config_folder" ]]; then
            log "$config_folder does not exist. Creating it now."
            mkdir -p "$config_folder"
        fi

        # Restore JourneyMapServer folder from backup
        if [[ -d "$backup_folder/$journey_map_folder" ]]; then
            log "Restoring $journey_map_folder to $config_folder"
            cp -r "$backup_folder/$journey_map_folder" "$config_folder/"
        else
            logWarning "$journey_map_folder not found in backup!"
        fi

        # Copy the changelog file to /data
        gtnh_changelog_file=$(mc-image-helper find --max-depth=1 --type=file --name="changelog*.md" "$base_dir")
        if [[ -n "$gtnh_changelog_file" ]]; then
          log "Copying changelog file to /data"
          cp -f "$gtnh_changelog_file" /data/
        fi

      else
        log "No .gtnh-version file detected! Assuming no old server exists. Proceed installing new server..."
        cp -R -f "${base_dir}"/* /data
      fi
      # Update .gtnh-version
      basename "$gtnh_download_path" > /data/.gtnh-version
      # Cleaning up
      rm -rf "$original_base_dir"
    
    else
      log "No update required: /data/.gtnh-version matches the selected version $(basename "$gtnh_download_path")."
    fi
  fi
}

function handleModrinthProjects() {
  : "${MODRINTH_ALLOWED_VERSION_TYPE:=release}"
  : "${MODRINTH_DOWNLOAD_DEPENDENCIES:=none}"
  if [[ -v MODRINTH_DOWNLOAD_OPTIONAL_DEPENDENCIES ]]; then
    logWarning "The variable MODRINTH_DOWNLOAD_OPTIONAL_DEPENDENCIES is removed."
    logWarning "        Use MODRINTH_DOWNLOAD_DEPENDENCIES=optional instead"
  fi

  if [[ -v MODRINTH_PROJECTS ]]; then

    if isType CUSTOM; then
      if ! [[ $MODRINTH_LOADER ]]; then
        logError "MODRINTH_LOADER must be set when using TYPE=CUSTOM and MODRINTH_PROJECTS"
        exit 1
      fi
      loader="${MODRINTH_LOADER,,}"
    elif isFamily HYBRID; then
      loader=${HYBRIDTYPE}
    elif isFamily VANILLA; then
      loader=datapack
    else
      loader="${TYPE,,}"
    fi

    mc-image-helper modrinth \
      --output-directory=/data \
      --world-directory="${LEVEL:-world}" \
      --projects="${MODRINTH_PROJECTS}" \
      --game-version="${VERSION}" \
      --loader="$loader" \
      --download-dependencies="$MODRINTH_DOWNLOAD_DEPENDENCIES" \
      --allowed-version-type="$MODRINTH_ALLOWED_VERSION_TYPE"
  fi
}

function handleCurseForgeFiles() {
  args=()
  if usesMods && ! usesPlugins; then
    args+=(--default-category mc-mods)
  elif usesPlugins && ! usesMods; then
    args+=(--default-category bukkit-plugins)
  fi

  case "${TYPE,,}" in
    forge|neoforge|fabric|quilt)
      args+=(--mod-loader "$TYPE")
      ;;
    *)
      if isFamily HYBRID; then
        # To disambiguate mc-mods we'll assume that hybrid servers
        # are blending Forge (rather than Fabric or NeoForge)
        args+=(--mod-loader "${HYBRIDTYPE}")
      fi
      ;;
  esac

  # shellcheck disable=SC2086
  # since we want CURSEFORGE_FILES to expand
  mc-image-helper curseforge-files \
    "${args[@]}" \
    ${CURSEFORGE_FILES}
}

handlePackwiz

handleModpackZip

handleListings

if [[ $MANIFEST ]]; then
  logError "MANIFEST is no longer supported."
  logError "       Use MODPACK_PLATFORM=AUTO_CURSEFORGE and CF_MODPACK_MANIFEST instead"
  exit 1
fi

if [[ $MODS_FORGEAPI_KEY || $MODS_FORGEAPI_FILE || $MODS_FORGEAPI_PROJECTIDS ]]; then
  logError "The MODS_FORGEAPI_FILE / MODS_FORGEAPI_PROJECTIDS feature is no longer supported"
  logError "      Use CURSEFORGE_FILES instead."
  exit 1
fi

handleGenericPacks

handleGTNH

handleModrinthProjects

if usesMods || usesPlugins; then
  handleCurseForgeFiles
fi

# If supplied with a URL for a config (simple zip of configurations), download it and unpack
if [[ "$MODCONFIG" ]]; then
case "X$MODCONFIG" in
  X[Hh][Tt][Tt][Pp]*[Zz][iI][pP])
    log "Downloading mod/plugin configs via HTTP"
    log "  from $MODCONFIG ..."
    curl -sSL -o /tmp/modconfig.zip "$MODCONFIG"
    if [ "$FAMILY" = "SPIGOT" ]; then
      mkdir -p /data/plugins
      unzip -o -d /data/plugins /tmp/modconfig.zip
    else
      mkdir -p /data/config
      unzip -o -d /data/config /tmp/modconfig.zip
    fi
    rm -f /tmp/modconfig.zip
    ;;
  *)
    log "Invalid URL given for modconfig: Must be HTTP or HTTPS and a ZIP file"
    ;;
esac
fi

exec "$(dirname "$0")/start-setupMounts" "$@"
